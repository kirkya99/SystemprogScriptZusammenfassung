<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Einf√ºhrung in die Netzwerkprogrammierung mit Sockets</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="fbc0a4db-d019-48fa-824d-b2fa63e12348" class="page sans"><header><h1 class="page-title">Einf√ºhrung in die Netzwerkprogrammierung mit Sockets</h1></header><div class="page-body"><h1 id="0c03e55a-e130-4577-a63e-b879e1fb1d9d" class="">Der Server </h1><p id="8ff46084-530b-42ea-bdc2-21634b35522a" class="">Zuerst erstellen wird unsere Serveranwendung. Unser Server soll Nachrichten, welche er vom Client erh√§lt an diesen zur√ºckschicken.</p><p id="34d223a8-76c7-4fd3-816f-61f1befed4d4" class="">Unser Server hat folgende Aufgaben:</p><ol type="1" id="4b7a0b14-80c7-4a90-ab9d-40d53322db3c" class="numbered-list" start="1"><li>Anlegen eines Sockets</li></ol><ol type="1" id="d53b212f-66dd-4200-848c-37630e772eef" class="numbered-list" start="2"><li>Binden des Sockets an eine IP-Adresse und einen Port</li></ol><ol type="1" id="780bbd2c-11df-4254-ae62-2207a391fe9a" class="numbered-list" start="3"><li>Verbinungswarteschlange einrichten</li></ol><ol type="1" id="bc249f21-b5fd-4ec6-a20a-61797caa8b77" class="numbered-list" start="4"><li>Verbindung annehmen</li></ol><ol type="1" id="73015009-67e8-4ed9-b29b-3db224b1d133" class="numbered-list" start="5"><li>Datenaustausch mit Client</li></ol><h2 id="33cc9ba3-0d1a-437c-b91a-22251c5e2d7e" class="">Anlegen eines Sockets</h2><p id="87fa8c6d-1d91-447a-951b-bcac85fe2aae" class="">Im ersten Schritt muss unser Server und sp√§ter auch unser Client einen Socket vom Betriebssystem anfordern. Die Syntax hierf√ºr ist unter UNIX folgende:</p><pre id="161a35b4-97d4-465a-ad90-19942a797ba9" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);</code></pre><p id="1b871967-d60e-411e-966a-24feff3e1675" class="">Als R√ºckgabewert erhalten Sie den Socket-Deskriptor. Diesen ben√∂tgen Sie, um den Socket anzusprechen. Falls es zu einem Fehler kam, gibt die Funktion den Wert <code>&#x27;-1&#x27;</code> zur√ºck.</p><p id="eb9c3f4a-797b-4766-abf7-23d6b48a1c96" class="">Der erste Parameter <code>domain</code> gibt die zu verwendende Adressdom√§ne an. Die vollst√§ndige Liste aller unterst√ºtzten Dom√§nen finden Sie in der Headerdatei <code>&lt;sys/socket.h&gt;</code>. In der folgenden Tabelle finden Sie eine kurze √úbersicht.</p><p id="674b7260-616e-4df9-a555-b66fe849b2d0" class=""><strong>Adressdom√§ne Bedeutung</strong></p><table id="a8d361cd-deca-4511-9afb-53d93eba9628" class="simple-table"><tbody><tr id="6888e5e7-ba8d-4fa4-82e1-9974fb4ec92a"><td id="Zfga" class="">AF_UNIX</td><td id="C`Je" class="">Unix Domain Socket</td></tr><tr id="688b6b9f-2e78-4e8b-be41-9b38be2b92e1"><td id="Zfga" class="">AF_INET</td><td id="C`Je" class="">IP-Protokoll Version 4</td></tr><tr id="cc8471f1-dde5-40b0-9031-1a6b1edd49b8"><td id="Zfga" class="">AF_INET6</td><td id="C`Je" class="">IP-Protokoll Version 6</td></tr></tbody></table><p id="a70a723f-e8e9-40ea-bace-824fd12e232a" class="">Der zweite Parameter <code>type</code> legt die √úbertragungsart des Sockets fest. F√ºr TCP verwenden Sie die Konstante <code>SOCK_STREAM</code> und f√ºr UDP die Konstante <code>SOCK_DGRAM</code>.</p><p id="96af18c2-eb00-4cb8-9b5f-1f84c36b0af7" class="">Der letzte Parameter bestimmt das Protokoll. Hier geben wir <code>‚Äò0‚Äô</code> an, um das Standardprotokoll zu verwenden. Bei <code>SOCK_STREAM</code> wird f√ºr TCP und bei <code>SOCK_DGRAM</code> wird UDP genutzt.</p><h2 id="ae4105ee-20fa-4918-a44f-194685395af3" class="">Binden des Sockets an eine IP-Adresse und einen Port</h2><p id="f44fab7c-f021-4a88-bc81-4cd59a2c5a15" class="">Unserem zuvor angelegten Socket binden wir nun an eine IP-Adresse und einen Port. Die Syntax ist:</p><pre id="39e6514c-0d00-4e73-91f6-c8d52716f461" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><p id="46e33e5d-b84d-4c4b-a6b6-fe8ef58d2bed" class="">Als ersten Parameter geben wird unseren angeforderten Socket an. Hierf√ºr ben√∂tigen wir den zuvor erhaltenen Socket-Deskriptor.</p><p id="823ac39f-f9db-4c15-8672-0e2bfac9cb7c" class="">Mit dem zweiten Parameter wird ein Zeiger auf eine Adresse und einen Port angegeben. F√ºr IPv4 wird das <code>struct sockaddr_in</code> verwendet, welches in <code>netinet/in.h</code> definiert ist:</p><pre id="5c7a9129-6c89-443e-8329-5991d753fcf3" class="code"><code>#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt;    // superset of previous

struct in_addr
{
        uint32_t       s_addr;     // address in network byte order
};

struct sockaddr_in
{
        sa_family_t    sin_family; // address family: AF_INET
        in_port_t      sin_port;   // port in network byte order
        struct in_addr sin_addr;   // internet address
};</code></pre><p id="bf868c78-d094-4793-a0ec-794317f35982" class="">Der letzte Parameter gibt die Gr√∂√üe der als zweiten Parameter √ºbergebenen Adressstruktur an.</p><p id="168fbb03-bfd2-4a1b-86fb-01ace6cf09c8" class="">Mit dem bisher Gelernten k√∂nnen wir nun folgendes schreiben:</p><pre id="2e565544-54fc-484d-aa0e-9e0151b9142c" class="code"><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int main(void)
{
	const in_port_t port = 8111;

	/* create socket */
	const int listen_sock = socket(AF_INET, SOCK_STREAM, 0);
	if(listen_sock &lt; 0)
	{
		perror(&quot;Could not create socket&quot;);
		return 1;
	}

	/* prepare socket address structure */
	struct sockaddr_in addr;
	memset(&amp;addr, 0, sizeof(addr));			//any fields not set below must be zero
	addr.sin_family = AF_INET;			//use IPv4
	addr.sin_addr.s_addr = htonl(INADDR_ANY);	//accept connections from all addresses and networks
	addr.sin_port = htons(port);			//set the port to use

	/* bind the socket to the address specified above */
	if(bind(listen_sock, (const struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0)
	{
		perror(&quot;Could not bind socket to address&quot;);
		return 1;
	}

	//‚Ä¶
	return 0;
}</code></pre><p id="60278ce1-b4cc-49ac-b7c8-4fd56416659a" class="">Dem aufmerksamen Leser  wird der Cast beim Aufruf von <code>bind()</code> aufgefallen sein:
<code>bind</code> erwartet einen Zeiger auf ein <code>struct sockaddr</code>, wir liefern aber einen auf <code>struct sockaddr_in</code>.</p><p id="981b24f9-f8b1-4243-b69f-e122be656d75" class="">Der Hintergrund hierf√ºr ist, dass das Socket-Interface allgemein gehalten ist und auch z.B. mit IPv6 funktioniert. Dazu wurde das generelle <code>struct sockaddr</code> definiert, welches <code>bind</code> als √úbergabeparameter dient (genauer: ein Zeiger darauf). F√ºr jede unterst√ºtze Adressdom√§ne gibt es au√üerdem eine weitere, spezialisierte Struktur, die sich einfacher als die allgemeine ausf√ºllen k√§sst und so aufgebaut ist, dass sie mit der allgemeinen Struktur kompatibel ist. Bei IPv4 ist das eben <code>struct sockaddr_in</code>. Da aber der Compiler von der Kompatibilit√§t nichts wei√ü, m√ºssen wird casten. </p><h2 id="19149216-2e55-4dad-a3e1-28aec3aba763" class="">Verbindungswarteschlange einrichten</h2><p id="ece3a3e3-3dbc-4c95-bd8c-6e4d969b5f6a" class="">Im n√§chsten Schritt muss eine Warteschlange f√ºr eingehende Verbindungen eingerichtet werden. Diese wird mit der Funktion <code>listen()</code> umgesetzt. Die Syntax ist die folgende:</p><pre id="4ec2bbb1-f6d7-45c8-a519-de02a0568277" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int listen(int sockfd, int backlog);</code></pre><p id="78bbcb58-8a5b-45f2-848a-432499ca6857" class="">Der erste Paramter gibt den Socket-Deskriptor an, f√ºr den die Warteschlange eingerichtet werden soll. Der zweite Parameter steuert die Gr√∂√üe der Warteschlange. Hier werden typischerweise kleinste Ganzzahlwerte zwischen 4 und 10 verwendet.</p><p id="b2f3bebf-79c7-4f6f-b912-fe6f70dd4980" class="">Bei einem Fehler gibt die Funktion den Wert <code>-1</code> zur√ºck. Sollte es zu keinem Fehlern gekommen sien, gibt die Funktion den Wert <code>0</code> zur√ºck. Mit diesem Wissen k√∂nnen wir folgende Fehlerabfrage einbauen:</p><pre id="d186a75b-02e2-4832-818c-346909abb06e" class="code"><code>if(listen(sock, 3) == -1)
{
	//Error handling
}</code></pre><h2 id="191221a5-9f9e-43cf-b804-1405c4bbbd1f" class="">Verbindung annehmen</h2><p id="6055c096-d829-4d2f-9c4b-d31937f60633" class="">Da die Warteschlange f√ºr eingehende Verbindungen nun eingerichtet ist, fehlt f√ºr einen erfolgreichen Verbindungsaufbau noch das Annehmen von Verbindungsanfragen. Hierf√ºr wird die Funktion <code>accept()</code> mit der folgenden Syntax verwendet:
</p><pre id="b75e1398-fef3-4d41-9367-ce6b187a09c3" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></pre><p id="eeaae124-00d0-4e0c-8603-384c0252008a" class="">Als R√ºckgabewert wird ein Socket-Deskriptor eines neuen Sockets zur√ºckgegeben.
DIeser ist mit dem Cilentsocket verbunden. Der Usprungssocket bleibt erhalten und kann weiter verwendet werden um weitere Verbindungsanfragen anzunehmen.</p><p id="cf7f7194-66df-4246-b965-51c218d35fe9" class="">Der erste Parameter gibt den Socket an, an weclhem Verbinungsanfragen ankommen.</p><p id="46a3c6d9-3538-481c-91dd-3f2982018546" class="">√úber den zweiten Parameter kann man sich die Netzwerkadresse und den Port des Clients geben lassen. Ist man an dieser Information nicht interessiert, so kann man hier und f√ºr den dritten Paramter einfach <code>NULL</code> √ºbergeben.</p><p id="96ffca3f-a3f7-4915-aa0b-80e49c91088f" class="">Der dritte Parameter ist ein Zeiger auf die Gr√∂√üe des als zweiten Parameters √ºbergebenen Puffers. Nach Abschluss des Aufrufes steht in <code>*addrlen</code> die tats√§chliche Gr√∂√üe der Adresse, sofern nicht <code>NULL</code> √ºbergeben wurde.</p><p id="ac20e3ee-8a86-4a9d-9226-021b15770827" class=""><strong>Hinweis:</strong> <code>accept()</code> blockiert solange, bis tats√§chlich (mindestens) eine Verbindungsanfrage in der Warteschlange steht.</p><h3 id="a7d3f73b-6366-49c7-b6ee-8fc829a35695" class="">Codebeispiel zum Annehmen von Verbindungen</h3><p id="27e3bcfd-b238-4269-b381-195da04cc895" class="">Aus dem bisher erlernten ergibt sich folgender Programmcode:</p><pre id="2e27f27d-c75c-4814-8932-a097191c3b35" class="code"><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int main(void)
{
    const in_port_t port = 8111;

    /* create socket */
    const int listen_sock = socket(AF_INET, SOCK_STREAM, 0);
    if(listen_sock &lt; 0)
    {
        perror(&quot;Could not create socket&quot;);
        return 1;
    }

    /* prepare socket address structure */
    struct sockaddr_in addr;
    memset(&amp;addr, 0, sizeof(addr));            //any fields not set below must be zero
    addr.sin_family = AF_INET;                 //use IPv4
    addr.sin_addr.s_addr = htonl(INADDR_ANY);  //accept connections from all addresses and networks
    addr.sin_port = htons(port);               //set the port to use

    /* bind the socket to the address specified above */
    if(bind(listen_sock, (const struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0)
    {
        perror(&quot;Could not bind socket to address&quot;);
        return 1;
    }

    /* mark socket to be accepting connections */
    if(listen(listen_sock, backlog) &lt; 0)
    {
        perror(&quot;Could not mark socket to be accepting connections&quot;);
        return 1;
    }

    /* wait for a client connection and accept it */
    const int client_sock = accept(listen_sock, NULL, NULL);
    if(client_sock &lt; 0)
    {
        perror(&quot;Could not accept client connection&quot;);
        return 1;
    }

    //‚Ä¶

    return 0;
}</code></pre><h2 id="4b6512b6-b8e7-497c-bc64-2aec7b9f5301" class="">Datenaustasch mit Client</h2><p id="45be968b-cece-4c44-88da-eb7a7b1db7c9" class="">Nach dem erfolgreichen Aufbauen einer Verbindung k√∂nnen nun Daten √ºber diese Verbindung ausgetauscht werden.</p><p id="6a62ba18-141a-4704-a31d-96d0111e71df" class="">Da unter Unix auch Sockets wie Dateien behandelt werden, k√∂nnen dazu die √ºblichen Ein-/Ausgabefunktionen <code>read()</code> und <code>write()</code> (zum Senden) verwendet werden:</p><pre id="1d2c7353-131b-49d5-8429-d0fe19b0ce3a" class="code"><code>#include &lt;unistd.h&gt;

ssize_t read(int fd, void *buf, size_t nbytes);
ssize_t write(int fd, const void *buf, size_t nbytes);</code></pre><p id="4567f3b2-6617-4c6d-aae6-7d395e0f2939" class="">Der erste Parameter gibt an, welche Datei gelesen oder geschrieben werden soll, also in unserem Fall von <code>accept()</code> zur√ºckgegebenen Verbindungs-Socket.</p><p id="942f2091-2136-4561-9bd9-5d07fcd38883" class="">Der zweite Parameter ist ein Zeiger auf einen Puffer, indem die gelesenen Daten abgefragt werden bzw. der die zu schreibenden Daten enth√§lt.</p><p id="051a6b10-d1af-4454-8ea1-428d3c437147" class="">Der dritte Parameter gibt an, wie viele Bytes maximal gelesen oder geschrieben werden.</p><p id="c63d1653-12fc-4da0-b28d-0c0819388608" class="">Der R√ºckgabewert ist die Anzahl der tats√§chlich gelesenen oder geschriebenen Bytes, oder im Fehlerfall <code>-1</code>. Wenn der Client die Verbindung schlie√üt, gilt das als Dateiende und <code>read()</code> liefert <code>0</code> zur√ºck.</p><p id="308697ae-38e3-4f09-8251-a705baf9e276" class="">Zus√§tzlich k√∂nnen f√ºr Sockets au√üerdem die FUnktionen <code>recv()</code> und <code>send()</code> verwendet werden. Diese erhalten zus√§tzlich noch einen vierten <code>flags</code>-Paramter, der dsa Verhalten beim Senden und Empfangen weiter beeinflusst. Insbesondere das Flag <code>MSG_WAITALL</code> ist beim Empfang f√ºr Bin√§rprotokolle zu empfehlen, denn dieses sorgt daf√ºr, dass <code>recv()</code> solange wartet, bis tats√§chlich die angeforderte Anzahl an Bytes eingetroffen ist (oder ein Fehler auftritt / das Verbindungsende erreicht wurde).</p><h2 id="b0009863-9b67-45fd-98c1-21da39a6e6c3" class="">Beenden der Verbindung</h2><p id="462785c1-0a82-4832-bb88-5d96375b720d" class="">Nachdem die Daten √ºbertragen sind, muss die Verbindung wieder geschlossen werden. Dies bewerkstelligen wir mit der Funktion <code>close()</code>:</p><pre id="e1049308-3f44-4e16-b175-57c939c73d0a" class="code"><code>#include &lt;unistd.h&gt;

int close(int fd);</code></pre><h2 id="c0767782-d5c0-4deb-bd02-8fb3b4194ad7" class="">Der fertige Server</h2><p id="3fdfee93-5469-43c5-bb7a-10f338979444" class="">Nachdem wir unseren Server um eine Empfangsschleife und das Schlie√üen der Verbinung erweitert haben, sieht der Code nun so aus:</p><pre id="8073009f-52bd-433a-9c2f-1e0c0a21a485" class="code"><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int main(void)
{
	const in_port_t port = 8111;

	/* create socket */
	const int listen_sock = socket(AF_INET, SOCK_STREAM, 0);
	if(listen_sock &lt; 0)
	{
		perror(&quot;Could not create socket&quot;);
		return 1;
	}

	/* prepare socket address structure */
	struct sockaddr_in addr;
	memset(&amp;addr, 0, sizeof(addr));			//any fields not set below must be zero
	addr.sin_family = AF_INET;			//use IPv4
	addr.sin_addr.s_addr = htonl(INADDR_ANY);	//accept connections from all addresses and networks
	addr.sin_port = htons(port);			//set the port to use

	/* bind the socket to the address specified above */
	if(bind(listen_sock, (const struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0)
	{
		perror(&quot;Could not bind socket to address&quot;);
		return 1;
	}

	/* mark socket to be accepting connections */
	if(listen(listen_sock, backlog) &lt; 0)
	{
		perror(&quot;Could not mark socket to be accepting connections&quot;);
		return 1;
	}

	/* wait for a client connection and accept it */
	const int client_sock = accept(listen_sock, NULL, NULL);
	if(client_sock &lt; 0)
	{
		perror(&quot;Could not accept client connection&quot;);
		return 1;
	}

	/* now receive data and send it back, until the connection closes */
	ssize_t bytes_read;
	char buf[buf_size];
	while((bytes_read = read(client_sock, buf, buf_size)) &gt; 0)
	{
		/* Process the received data. In our case, we
		 * just print it and send it back. Note that we
		 * probably do not get a null-termination, so be
		 * careful here!
		 */
		write(STDOUT_FILENO, buf, (size_t)bytes_read);
		write(client_sock, buf, (size_t)bytes_read);
	}

	if(bytes_read &lt; 0)
	{
		perror(&quot;Error receiving data&quot;);
		return 1;
	}

	close(listen_sock);
	close(client_sock);
	return 0;
}</code></pre><p id="26ac9f89-b88a-4e50-8706-944fcc3334f7" class="">Das Schlie√üen der Sockets erfolgt hier, um Platz zu sparen, nur exemplarisch nach einem erfolgreichen Ablauf des Programmms. Das ist aber nicht weiter schlimm, denn beim Beenden eines Prozesses schlie√üt das Betriebssystem ohnehine alle Dateien des Prozesses.</p><h1 id="d3b2cf36-0728-40dd-ab4f-b144f29cd519" class="">Client</h1><p id="1bd23dda-07bd-47bd-86c3-a09a2921dc5f" class="">Nachdem wir uns mit telnet odet telcat davon √ºberzeugt habnem dass der Server wie gew√ºnscht funktioniert, implementieren wir nun einen Client f√ºr unseren Server.</p><p id="153e944f-2e1e-4d7d-8339-112ce21ba7cd" class="">Der Client hat dabei folgenden Ablauf:</p><ol type="1" id="076da2f9-c86f-44ee-83ad-c3a27b2a163f" class="numbered-list" start="1"><li>Aufl√∂sen des Hostnamens in IP-Adressen</li></ol><ol type="1" id="475dceea-3855-40eb-a253-563c4ebc58fa" class="numbered-list" start="2"><li>Anfordern eines Sockets und Verbindungsaufbau</li></ol><ol type="1" id="d4d0436d-87e0-4820-8979-6dd9f5fe0f1d" class="numbered-list" start="3"><li>Datenaustausch mit dem Server</li></ol><h2 id="8ce508f9-73a7-4776-8ccd-dc706a91ad74" class="">Namensaufl√∂sung mit <code>getaddrinfo()</code></h2><p id="207420f5-774e-4485-bad9-7398af77ac4d" class="">F√ºr den Verbindungsaufbau wird ein Socket-Adressstruktur ben√∂tigt, wie wir sie schon von der Implementierung des Servers kennen. Grunds√§tzlich k√∂nnten wir diese mit dem bisherigen Wissen auch von Hand ausf√ºllen. Dazu muss aber die IP-Adresse des Servers bekannt sein.</p><p id="fbef9871-0384-4d01-bcfc-b9870a4d4e91" class="">Als Anwender von netzwerkf√§higen Programmen m√∂chten wir nicht umst√§ndlich mit IP-Adressen hantieren, denn einen DNS-Namen wie beispielsweise <a href="http://www.rwu.de"><em>www.rwu.de</em></a> k√∂nnen wir uns besser merken als <em>141.69.5.100</em>, die dazugeh√∂rige IP-Adresse.
Unser Client soll deshalb eine DNS-Namensaufl√∂sung durchf√ºhren und sozusagen den Namen in eine Socket-Adresstruktur umwandeln.</p><p id="c995e22f-33b7-45d6-81f7-d434a85f2900" class="">Dazu stellt Unix mehrere Funktionen zur Verf√ºgung. Die allgemeinste (weil auch mit IPv6 funktionierende) und empfohlene hei√üt <code>getaddrinfo()</code> und kommt zusammen mit zwei weiteren Hilfsfunktionen:</p><pre id="5168fa6a-57e3-47ce-a6b6-aaa34cac1d1c" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getaddrinfo(const char *node, const char *service,
                const struct addrinfo *hints,
                struct addrinfo **res);

void freeaddrinfo(struct addrinfo *res);

const char *gai_strerror(int errcode);</code></pre><p id="4873804a-0c11-4441-aefc-72ebff69afb0" class="">Der erste Parameter von <code>getaddrinfo()</code> ist der aufzul√∂sende Hostname, also z.B.: <a href="http://www.rwu.de"><em>www.rwu.de</em></a>. Es kann auch eine IP-Adresse als String angegeben werden, sodass keine Namensaufl√∂sung erfolgt, sondern im Wesentlichen nur die Socket-Adressstruktur ausgef√ºllt wird.</p><p id="ca3da58a-cd81-43ea-bdc3-49ac63ee818e" class="">√úber den zweiten Parameter wird der Port angegeben. Mit den Standardeinstellungen funktionieren sowohl textuelle Angaben wie <em>‚Äúhttp‚Äù</em>, als auch einfach Portnummern, die als String √ºbergeben werden.</p><p id="566baec8-04dd-4842-b7c7-8afd7ef129a0" class="">Der dritte Parameter ist ein Zeiger auf ien <code>struct addrinfo</code>, deren Aufbau weiter unten erkl√§rt wird. √úber diesen Paramter wird beeinflusst, welches IP-Protokoll (4,, 6 oder beide) und ob TCP oder UDP verwendet werden soll, er stellt also eine Art FIlter f√ºr die Ergebnisse dar.</p><p id="5afb7317-0f54-411e-8e91-84e7939c4f14" class="">Der vierte Parameter liefert das Ergebnis. Es handelt sich um die Adresse eines Zeigers auf eine <code>struct addrinfo &#x27;gai_res</code> und √ºbergibt dessen Adresse mit <code>&amp;gai_res</code> an <code>getaddrinfo()</code>, dann zeigt <code>gai_res</code> nach dem erfolgreichen Ende des Aufrufs auf das Ergebnis. Das Ergebnis muss mit <code>freeaddrinfo()</code> freigegeben werden, sobald es nicht mehr ben√∂tigt wird.</p><p id="d5a4cedd-001c-4889-8c2e-b43092b1d198" class="">Der R√ºckgabewert ist <code>0</code>, wenn akkes gut gegangen ist oder ansonsten ein Fehlercode, der an <code>gai_strerror()</code> √ºbergeben werden kann, um eine Fehlermeldung zu erhalten</p><p id="0a469101-6dbc-4c7b-8eee-42edf08e82ac" class="">Die bei den Parametern <code>hints</code> und <code>res</code> verwendete Struktur hat folgenden Aufbau:</p><pre id="168d5c61-5b38-44d3-a93b-dbced177b15d" class="code"><code>struct addrinfo
{
    int              ai_flags;
    int              ai_family;
    int              ai_socktype;
    int              ai_protocol;
    socklen_t        ai_addrlen;
    struct sockaddr *ai_addr;
    char            *ai_canonname;
    struct addrinfo *ai_next;
};</code></pre><p id="7d9c94cd-66d4-4523-8ec7-86a67759ee57" class="">f√ºr die <code>hints</code> asl Eingabeparameter m√ºssen nur die ersten vier Parameter ausgef√ºllt werden, der Rest muss mit <code>0</code> initialisiert werden:</p><p id="60eeee95-a3bd-4a07-b138-4456f5fd68d1" class=""><strong>ai_flags:</strong> Flags f√ºr die Namensaufl√∂sung. H√§ufig benutzt wird z.B. <code>AI_NUMERICSERV</code>, wodurch nur Zahlenstrings als service akzeptiert werden.</p><p id="ef6302f5-e600-4bfc-af10-fa5fb8259bf3" class=""><strong>ai_family:</strong>¬†<code>AF_INET</code>¬†f√ºr IPv4,¬†<code>AF_INET6</code><em> </em>f√ºr IPv6 oder¬†<code>AF_UNSPEC</code><em> </em>f√ºr beides (vgl. Anlegen des Sockets beim Server).</p><p id="3c1a4a03-2229-41dc-8af6-09155b9ce508" class=""><strong>ai_socktype:</strong> <code>SOCK_STREAM</code> f√ºr TCO, <code>SOCK_DGRAM</code> f√ºr UDP.</p><p id="8b6e87ad-fcf7-41ca-ac9a-2c298bd27d7f" class=""><strong>ai_protocol:</strong> Wie beim Aufruf von socket kann hier das Protokoll genauer spezifiziert werden. Normalerweise einfach <code>0</code></p><p id="5acf2c86-7c68-4d9d-a904-a3f722792839" class="">Das Ergebnis des Aufrufs ist eine verkettete Liste von passenden <code>sockaddr</code>-Strukturen, bei denen zus√§tzlich die weiteren Elemente ausgef√ºllt sind:</p><p id="55669c9a-85af-43b2-94ea-b22bf00cc2b7" class=""><strong>ai_addrlen:</strong> Die L√§nge der Socket-Adressstruktur. Diese wird beim Verbindungsaufbau ben√∂tigt.</p><p id="9ddfd902-0c5a-4b07-9ccf-966f10a9bcf9" class=""><strong>ai_addr:</strong> Ein Zeiger auf eine Socket-Adresstruktur, die eine zur Anfrage passende IP-Adresse enth√§lt.</p><p id="056c1d4c-4a19-451a-b355-39881637299d" class=""><strong>ai_canonname:</strong> Wird hier nicht ben√∂tigt und nicht behandelt.</p><p id="9f857fae-3e1a-4d56-8628-86985be362c5" class=""><strong>ai_next:</strong> Ein Zeiger auf das n√§chste Ergebnis (verkettete Liste) oder <code>NULL</code> beim letzten Ergebnis.</p><h3 id="f41cdc1f-1db7-47e1-be09-c85ed586942a" class="">Beispiel zu <code>getaddrinfo()</code></h3><p id="4d072a14-456f-4440-aaa2-cb01e2566e7a" class="">Was in der Theorie furchbar kompliziert klingt, ist in unserem Fall gl√ºcklicherweise in der Praxis ganz einfach. Folgendes Codebeispiel zeigt, wie die Funktion typischerweise verwendet wird:</p><pre id="05c0ec3c-d142-417d-8870-9e0e46f51d77" class="code"><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int main(int argc, char **argv)
{
	const char *port = &quot;8111&quot;;

	if(argc != 2)
	{
		fprintf(stderr, &quot;usage: %s HOSTNAME\n&quot;, argv[0]);
		return 1;
	}

	/* prepare hints for DNS name resolution via getaddrinfo */
	struct addrinfo hints;
	memset(&amp;hints, 0, sizeof(hints));
	hints.ai_flags = AI_NUMERICSERV;	//port is given as a number, don&#x27;t perform service resolution
	hints.ai_family = AF_INET;		//only return IPv4 addresses
	hints.ai_socktype = SOCK_STREAM;	//only stream sockets
	hints.ai_protocol = 0;			//same as the protocol parameter of socket (0=default)

	/* resolve hostname into IP addresses */
	struct addrinfo *gai_res;
	const int gai_status = getaddrinfo(argv[1], port, &amp;hints, &amp;gai_res);
	if(gai_status != 0)
	{
		fprintf(stderr, &quot;Could not resolve hostname: %s\n&quot;, gai_strerror(gai_status));
		return 1;
	}

	//‚Ä¶
	freeaddrinfo(gai_res);
	//‚Ä¶
	return 0;
}</code></pre><p id="7a24cba3-3c9b-4500-97a6-868abdfc7584" class="">Gar nicht so schlimm, oder?</p><p id="eab3855a-e843-4b18-8f95-d33e728de03d" class="">Im n√§chsten Schritt benutzen wir nun die von <code>getaddrinfo()</code> erhaltenen Informationen, um den Client mit dem Server zu verbinden.</p><h2 id="f4e7eade-3884-4432-9f69-b79bc4e20b6f" class="">Verbindungsaufbau mit <code>connect()</code></h2><p id="96f3c7fb-67bc-4073-aaf0-e9238db72518" class="">Auch auf der Seite des Clients muss ein Socket erzeugt werden. Dies geschieht wieder mit der Funktion <code>socket()</code>, die bereits beim Server erkl√§rt wurde. Als √úbergabeparameter verwenden wir einfach die von <code>getaddrinfo()</code> gelieferten Werte aus der <code>struct addrinfo</code>.</p><p id="8c45b1c2-28e1-4c5b-ade6-1e1fc91715e3" class="">Das Gegenst√ºck zu <code>bind()</code> auf der Seite des Servers hei√üt im Client <code>connect()</code>.
Diese Funktion stellt √ºber den Socket die tats√§chliche Verbindung zum Server her und sieht folgenderma√üen aus:</p><pre id="dd23a6b2-9e54-4781-baae-4e0dbef7d26d" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><p id="ede92ed4-d8b5-4ace-b9f2-6dc750081a22" class="">Der erste Parameter ist der Filedeskriptor unseres Sockets.</p><p id="1f6a511d-ebfe-43fd-a525-319ec9c48737" class="">Die beiden anderen Parameter sind die schon bekannte Socket-Adressstruktur und deren L√§nge, so wie wir sie von <code>getaddrinfo()</code> bekommen.</p><h3 id="617ebc49-6fa7-40f5-9263-966f449f531f" class="">Beispiel zum Verbindungsaufbau</h3><p id="b3d4d933-25e0-41dc-bd88-94045d67b02a" class="">Nachdem nun die n√∂tigen Funktionen f√ºr den Verbindungsaufbau bekannt sind, ist die Implementierung nicht mehr schwer.</p><p id="a70c2373-0163-456f-967e-72a606e15218" class="">Zu beachten ist jedoch, dass die Namensaufl√∂sung mehrere Adressen zur√ºckliefern kann. Falls der Verbindungsaufbau mit der ersten Adresse nicht klappt, hei√üt das nicht unbedingt, dass der Server nicht erreichbar ist, denn es kann sein, dass es mit einer der weiteren Adressen dann doch funktioniert. es m√ºssen also alle Adressen durchprobiert werden - solange, bis entweder eine Verbindung steht, oder wir keine weiteren Adressen mehr haben. Falls wir danach immer noch keine Verbindungen haben, dann behandeln wir das als Fehler. Wenigstens k√∂nen wir uns dann aber nicht vorwerfen lassen, nicht unser Bestes getan zu haben‚Ä¶</p><p id="3b287914-d5ef-42e7-81c1-730b88d15586" class="">Wenn wir das ber√ºcksichtigen, dann k√∂nnen wir den Verbindungsaufbau wie folgt programmieren:</p><pre id="0b8e3476-b619-4bf3-b1ce-5a8338dd956e" class="code"><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int main(int argc, char **argv)
{
	const char *port = &quot;8111&quot;;
	const size_t buf_size = 1024;

	if(argc != 2)
	{
		fprintf(stderr, &quot;usage: %s HOSTNAME\n&quot;, argv[0]);
		return 1;
	}

	/* prepare hints for DNS name resolution via getaddrinfo */
	struct addrinfo hints;
	memset(&amp;hints, 0, sizeof(hints));
	hints.ai_flags = AI_NUMERICSERV;	//port is given as a number, don&#x27;t perform service resolution
	hints.ai_family = AF_INET;		//only return IPv4 addresses
	hints.ai_socktype = SOCK_STREAM;	//only stream sockets
	hints.ai_protocol = 0;			//same as the protocol parameter of socket (0=default)

	/* resolve hostname into IP addresses */
	struct addrinfo *gai_res;
	const int gai_status = getaddrinfo(argv[1], port, &amp;hints, &amp;gai_res);
	if(gai_status != 0)
	{
		fprintf(stderr, &quot;Could not resolve hostname: %s\n&quot;, gai_strerror(gai_status));
		return 1;
	}

	/* getaddrinfo might return more than one candidate. Try them one by one,
	 * until we successfully establish a connection.
	 */
	int sock = -1;
	for(const struct addrinfo *it=gai_res; it!=NULL &amp;&amp; sock==-1; it=it-&gt;ai_next)
	{
		sock = socket(it-&gt;ai_family, it-&gt;ai_socktype, it-&gt;ai_protocol);
		if(sock &gt;= 0)
		{
			if(connect(sock, it-&gt;ai_addr, it-&gt;ai_addrlen) != -1)
				fprintf(stderr, &quot;Connected.\n&quot;);
			else
			{
				close(sock);
				sock = -1;
			}
		}
	}
	freeaddrinfo(gai_res);
	if(sock == -1)
	{
		fprintf(stderr, &quot;Unable to get a connection.\n&quot;);
		return 1;
	}

	//‚Ä¶
	return 0;
}</code></pre><h2 id="9674a04a-e0d7-4c9c-b318-e5b47b856de4" class="">Der fertige Client</h2><p id="33dbf4af-0e99-4b82-8876-83a253b70d67" class="">Nachdem der Client sich mit dem Server verbunden hat, kann er die bereits bekannten Funktionen <code>read()</code>/<code>recv()</code> und <code>write()</code>/<code>send()</code> verwenden, um Daten vom Server zu empfangen bzw. um Daten zu diesem zu senden.</p><p id="c8ab35e0-1eb6-4c6b-8c1d-bf3081a73fe2" class="">Wir  vervollst√§ndigen unseren Client nun so, das er in einer Schleife‚Ä¶</p><ol type="1" id="e8ab290a-622d-4d6b-a1ec-a3870800048f" class="numbered-list" start="1"><li>‚Ä¶ Daten von der Standardeingabe liest, solange das Dateiende (im Terminal Ctrl+D) noch nicht erreicht wurde,</li></ol><ol type="1" id="f2bf803e-9bb2-4d2a-9959-4586151042f0" class="numbered-list" start="2"><li>diese Daten an den Server schickt,</li></ol><ol type="1" id="fcaa1605-9cd9-4ca2-aea2-aab5704c6f73" class="numbered-list" start="3"><li>eine Antwort vom Server empf√§ngt und</li></ol><ol type="1" id="ff224e69-adfa-45b1-9810-0da76b6adbe9" class="numbered-list" start="4"><li>diese auf der Konsole ausgibt.</li></ol><p id="c12b1697-2deb-4823-af59-d88a0485c718" class="">Damit sieht der fertige Client wie folgt aus:</p><pre id="358f9690-244c-430a-b4cf-fc302e5b7d33" class="code"><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int main(int argc, char **argv)
{
	const char *port = &quot;8111&quot;;
	const size_t buf_size = 1024;

	if(argc != 2)
	{
		fprintf(stderr, &quot;usage: %s HOSTNAME\n&quot;, argv[0]);
		return 1;
	}

	/* prepare hints for DNS name resolution via getaddrinfo */
	struct addrinfo hints;
	memset(&amp;hints, 0, sizeof(hints));
	hints.ai_flags = AI_NUMERICSERV;	//port is given as a number, don&#x27;t perform service resolution
	hints.ai_family = AF_INET;		//only return IPv4 addresses
	hints.ai_socktype = SOCK_STREAM;	//only stream sockets
	hints.ai_protocol = 0;			//same as the protocol parameter of socket (0=default)

	/* resolve hostname into IP addresses */
	struct addrinfo *gai_res;
	const int gai_status = getaddrinfo(argv[1], port, &amp;hints, &amp;gai_res);
	if(gai_status != 0)
	{
		fprintf(stderr, &quot;Could not resolve hostname: %s\n&quot;, gai_strerror(gai_status));
		return 1;
	}

	/* getaddrinfo might return more than one candidate. Try them one by one,
	 * until we successfully establish a connection.
	 */
	int sock = -1;
	for(const struct addrinfo *it=gai_res; it!=NULL &amp;&amp; sock==-1; it=it-&gt;ai_next)
	{
		sock = socket(it-&gt;ai_family, it-&gt;ai_socktype, it-&gt;ai_protocol);
		if(sock &gt;= 0)
		{
			if(connect(sock, it-&gt;ai_addr, it-&gt;ai_addrlen) != -1)
				fprintf(stderr, &quot;Connected.\n&quot;);
			else
			{
				close(sock);
				sock = -1;
			}
		}
	}
	freeaddrinfo(gai_res);
	if(sock == -1)
	{
		fprintf(stderr, &quot;Unable to get a connection.\n&quot;);
		return 1;
	}

	/* now send data and receive it back from the server */
	char buf[buf_size];
	ssize_t bytes_read_stdio, bytes_read_socket;
	while((bytes_read_stdin = read(STDIN_FILENO, buf, buf_size)) &gt; 0)
	{
		if(write(sock, buf, (size_t)bytes_read_stdin) != bytes_read_stdin)
		{
			perror(&quot;Error sending message&quot;);
			return 1;
		}

		bytes_read_socket = read(sock, buf, buf_size);
		if(bytes_read_socket &lt; 0)
		{
			perror(&quot;Error receiving data&quot;);
			return 1;
		}

		printf(&quot;response: &quot;);
		fwrite(buf, 1U, bytes_read_socket, stdout);
		fflush(stdout);
	}

	close(sock);
	return 0;
}</code></pre><p id="78872eb2-79aa-42d6-acee-9b40020ee242" class="">Auch hier schlie√üen wir wieder am Schluss den Socket.</p><p id="4b53cc86-3715-43b5-9c2d-846daead6697" class="">Das war‚Äôs, wir sind fertig!</p><p id="aef3f2c7-7712-4351-8f18-33d9e8c8c7bd" class="">
</p></div></article></body></html>